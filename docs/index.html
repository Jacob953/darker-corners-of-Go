<!DOCTYPE html>
<html lang='zh'>

    <head>
	<meta name="generator" content="Hugo 0.99.0" />
    <meta charset="utf-8" />
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <meta name="author"      content="" />
    <meta name="description" content="《Darker Corner of Go》独译（已授权）: Jacob953 Yu" />

    <title>Go 鲜为人知的角落</title><link rel="stylesheet" href="/darker-corners-of-go/assets/fonts/SourceSansPro/stylesheet.css" />
<link rel="stylesheet" href="/darker-corners-of-go/assets/css/styles.css" />

</head>
    <body>

        <header id="page-header">

    

    <h1 id="page-title">Go 鲜为人知的角落</h1>

    
        <div id="page-short-desc">《Darker Corner of Go》独译（已授权）: Jacob953 Yu</div>
    </header>



 
    <nav id="page-toc">
        <h2>目录</h2>
        
        <ul>
            <a href='#%e7%ac%ac-0-%e7%ab%a0-%e4%bb%8b%e7%bb%8d'>第 0 章 介绍</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-1-%e7%ab%a0-%e4%bb%a3%e7%a0%81%e6%a0%bc%e5%bc%8f%e5%8c%96'>第 1 章 代码格式化</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-2-%e7%ab%a0-%e5%8c%85%e5%af%bc%e5%85%a5'>第 2 章 包导入</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-3-%e7%ab%a0-%e5%8f%98%e9%87%8f'>第 3 章 变量</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-4-%e7%ab%a0-%e8%bf%90%e7%ae%97%e7%ac%a6'>第 4 章 运算符</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-5-%e7%ab%a0-%e5%b8%b8%e9%87%8f'>第 5 章 常量</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-6-%e7%ab%a0-%e5%88%87%e7%89%87-%26-%e6%95%b0%e7%bb%84'>第 6 章 切片 &amp; 数组</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-7-%e7%ab%a0-%e5%ad%97%e7%ac%a6%e4%b8%b2-%26-%e5%ad%97%e8%8a%82%e6%95%b0%e7%bb%84'>第 7 章 字符串 &amp; 字节数组</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-8-%e7%ab%a0-%e5%93%88%e5%b8%8c'>第 8 章 哈希</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-9-%e7%ab%a0-%e5%be%aa%e7%8e%af'>第 9 章 循环</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-10-%e7%ab%a0-switch-%26-select-%e8%af%ad%e5%8f%a5'>第 10 章 switch &amp; select 语句</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-11-%e7%ab%a0-%e5%87%bd%e6%95%b0'>第 11 章 函数</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-12-%e7%ab%a0-%e5%8d%8f%e7%a8%8b'>第 12 章 协程</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-13-%e7%ab%a0-%e6%8e%a5%e5%8f%a3'>第 13 章 接口</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-14-%e7%ab%a0-%e7%bb%a7%e6%89%bf'>第 14 章 继承</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-15-%e7%ab%a0-%e5%b9%b3%e7%ad%89%e6%80%a7'>第 15 章 平等性</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-16-%e7%ab%a0-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86'>第 16 章 内存管理</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-17-%e7%ab%a0-%e6%97%a5%e5%bf%97'>第 17 章 日志</a>
        </ul>
        
        <ul>
            <a href='#%e7%ac%ac-18-%e7%ab%a0-%e6%97%b6%e9%97%b4'>第 18 章 时间</a>
        </ul>
        
    </nav>

        <main id="page-content">
    
        
    
        <h1 id="第-0-章-介绍">第 0 章 介绍</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="译者序">译者序</h2>
<p>决定翻译《Darker Corners of Go》那日，与 Rytis 先生结束初步交流时，已经凌晨 5 点了，想来更多是一种冲动。自从开始学习 Go 以来，越来越感到 Go 语言核心理论的简单美。
在学习 Go 之初，我也硬着头皮去仔细阅读过《Effective Go》。但对于一个初学者来说，很难领会“圣经”中所表达的核心理念。</p>
<p>于是，我试着去阅读《Darker Corners of Go》，精确、易懂、简短，以类型的方式对陷阱进行分类。尽管它不是很典型的入门类型书籍，但它依然让我直观地感受到了 Go 语言的特性，还帮助我更快地锁定查阅的范围。
所以，我打算干脆将它用更加地道的方式翻译出来，直接分享给大家。一方面，可以锻炼自己的英文水平，面向更加开阔的技术世界；另一方面，可以对 Go 有更加深入的了解，还可以为 Go 的中文资源做贡献。</p>
<p>这篇文章的篇幅很短，所以翻译得比较轻松，以不至于萌生放弃的念头。翻译工作仍在继续，我会逐步发布新的章节，在此面向中文社区的 Gopher 征求意见，希望给读者带来更好的阅读体验。
这本书是根据《Darker Corners of Go》的电子版翻译过来的，与网上的电子版有一定的差异，有些内容是电子版没有的，或许后续会更新上去。</p>
<p>实际上，在多年前，Kyle Quest 发布过一篇 &ldquo;50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs&rdquo;，当然，这篇文章也有中文译本。
那篇文章以难度高低的方式对陷阱进行分类，而《Go 鲜为人知的角落》以类型的方式对陷阱进行分类。对于一个经验不足的 Gopher 来说，我认为后者或许更易被接受和学习。</p>
<p>由于本人也是 Gopher 新手，翻译过程中难免会有一些错误和问题，还希望各位高手批评指正。如果您觉得翻译或内容中有任何错误和问题，请您及时反馈给我，以便及时地进行修正：jacob953@csu.edu.cn</p>
<p>最后，我要感谢 Rytis Bieliunas 先生，是他给予了我极大的信任，让我以独译的角色翻译这本书，并时刻关注译本的进度，同时也要感段桂华女士，在翻译筹备过程中，是她在背后给予了我很多支持。</p>
<p>我希望本书能对那些想了解、学习和研究 Go 的人们有所帮助！</p>
<h2 id="作者序">作者序</h2>
<h3 id="这是什么">这是什么？</h3>
<p>在我刚开始学习 Go 的时候，读过一些相关的介绍书籍和语言规范，并且在此之前，我已经熟悉过其他几种编程语言。
尽管如此，在学习了这些书籍之后，我认为我对 Go 的了解真的不够多，很难进行实际的工作。
我觉得我对 Go 的工作方式了解得还不够深入，可能需要掉进很多坑里，才能对使用 Go 有所把握。</p>
<p><strong>事实证明，我的判断是对的。</strong></p>
<p>虽然 <code>简单</code>、<code>诗意</code>、<code>简洁</code> 是 Go 语言的核心理论，但当你深入使用 Go 时，你会发现，它的许多创造性方法会使你掉进坑里。</p>
<p>目前为止，在使用 Go 制作应用程序的这几年时间中，我踩过数不胜数的坑，于是，我打算将这些经验总结到一起，为 Go 的新手们编写一份指南。</p>
<p>我的目标是将 Go 中的各种可能让新开发者意料之外的知识点都收集到一起，这也许还能对一些不寻常的功能有所启发。
希望这样可以为读者节省大量的查询和调试时间，并尽可能避免一些代价昂贵的漏洞。</p>
<p>在阅读这本书之前，我认为你应该至少已经知道 Go 的语法，才能确保这本书对你是有用的。如果你已经有一定 Go 的编程经验，或已经熟悉其他编程语言，并且希望学习 Go，那就最好不过了。</p>
<p>如果你发现书籍中有撰写错误的地方，或者我总结的例子中没有包括令你最意外的 Go 的用法，请联系我：rytbiel@gmail.com。</p>
<p>非常感谢 
    <span class="link-wrapper">
        <a
            
            href="https://rtfb.lt/"
            target="_blank"
        >
            Vytautas Shaltenis
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
 和 
    <span class="link-wrapper">
        <a
            
            href="https://jlforrest.wordpress.com/"
            target="_blank"
        >
            Jon Forrest
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
 ，在他们的帮助下，这本书变得更加完整。</p>

    

    
        
    
        <h1 id="第-1-章-代码格式化">第 1 章 代码格式化</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="gofmt">gofmt</h2>
<p>Go 大部分代码的格式化都是由 gofmt 工具强制执行的。gofmt 可以对源文件进行自动修改，例如，对导入的声明进行排序和对代码应用缩进等。
这是自切片面包以来最好的东西，因为它让开发人员不必再去争论这些无关紧要的事情。例如，使用制表符进行缩进，使用空格进行对齐，对代码风格的争论便到此为止。</p>
<p>你完全可以不使用 gofmt 工具，但如果你真的使用它，你就不能把它配置成一种特定的格式化风格。该工具完全没有提供任何代码格式化的选项，而这正是重点所在——
提供一种统一的、“足够好”的格式化风格。这可能没有人喜欢的风格，但 Go 的开发者最终决定 <strong>统一胜于完美</strong>。</p>
<p>统一风格和自动格式化代码有很多好处，包括但不限于：</p>
<ul>
<li>在代码审查中，你不需要花时间在格式化问题上；</li>
<li>你不需要再与强迫症的同事去争论，开头的大括号应该放在哪里，或者应该用什么来做缩进。你的所有热情和精力都可以更有意义的地方。</li>
<li>代码更容易写：你不需要担心代码的格式化细节。</li>
<li>代码更容易读：你不需要在去适应不熟悉的代码风格。</li>
</ul>
<p>大多数流行的 IDE 都有 Go 的插件，会在保存源文件时自动运行 gofmt。</p>
<p>如果必要，你可以使用诸如 goformat 此类第三方工具自定义 Go 的代码风格。</p>
<h2 id="长行代码">长行代码</h2>
<p>gofmt 不会尝试分解长行代码，但你可以利用有诸如 golines 等第三方工具可以做到这一点。（一行代码不建议超过 200 个字母）</p>
<h2 id="正括号">正括号</h2>
<p>在 Go 中，正括号必须放在行尾。有趣的是，这并不是由gofmt强制执行的，而是Go词法分析器实现方式的副作用。
不管有没有 gofmt，正括号都不能放在新的一行上：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 缺少函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 语法错误：不期望分号或换行在 { 前。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 没毛病!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多行声明中的逗号">多行声明中的逗号</h2>
<p>在 Go 中，初始化 Slice, Array, Map 或结构体时，要在新的一行之前使用逗号。许多语言都允许使用尾部逗号，一些代码风格指南也鼓励这样使用。
但在 Go 中，它们是强制性的。这样，就可以在不修改无关代码行的情况下，重新排列行或添加新行。这也意味着在代码审查的差异中，可以减少干扰。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#75715e">// 这些都是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>,}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 语法错误，没有尾部逗号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 语法错误：不期望换行，期望是 , 或 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结构体也是如此：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 语法错误：不期望换行，期望是 , 或 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Two</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-2-章-包导入">第 2 章 包导入</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="未使用的导入包">未使用的导入包</h2>
<p>带有未使用导入包的 Go 程序是无法进行编译的。这是该语言的特点，因为导入包会降低编译器的速度。
在大型程序中，导入未使用的包会对编译时间产生重大影响。</p>
<p>为了在开发过程中使编译器正常运行，你可以以下方式导入未使用的包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 参照导入未使用的包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Round</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="goimports">goimports</h2>
<p>更好的解决方案是使用 goimports 工具，它可以删除未引用的导入包。更棒的是，它试图自动找到并添加缺失的包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 导入而未使用：&#34;math&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// 未定义：fmt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>运行 goimports：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./goimports main.go            
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>大多数流行的 IDE 的 Go 插件在保存源文件时，会自动运行 goimports。</p>
<h2 id="下划线导入">下划线导入</h2>
<p>以下划线的方式导入包只是为了包的副作用。以这种方式导入包，程序会创建包级变量并运行包的 
    <span class="link-wrapper">
        <a
            
            href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a"
            target="_blank"
        >
            init 函数
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">package1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">package1Function</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Package 1 side-effect&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">globalVariable</span> = <span style="color:#a6e22e">package1Function</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Package 1 init side effect&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>在 package2 中：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">package2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">package1</span>
</span></span></code></pre></div><p>这将打印出信息并初始化 globalVariable：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Package <span style="color:#ae81ff">1</span> side-effect
</span></span><span style="display:flex;"><span>Package <span style="color:#ae81ff">1</span> init side effect
</span></span></code></pre></div><p>多次导入一个包（e.g. 在 main 包及其引用的其他包中），只运行一次 init 函数。</p>
<p>下划线导入在 Go 运行时库中使用。例如，导入 net/http/pprof 会调用它的 init 函数，以暴露可以提供调试信息的 HTTP 端点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
</span></span></code></pre></div><h2 id="点导入">点导入</h2>
<p>点导入允许在没有限定词的情况下，访问导入的包中的标识符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#e6db74">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sin</span>(<span style="color:#ae81ff">3</span>)) <span style="color:#75715e">// 引用 math.Sin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p>关于点导入是否应该从语言中删除，有一个公开的辩论。Go 团队不建议在除了在测试包之外的地方使用它们。
这使得程序更难阅读，因为不清楚像 Quux 这样的名字是在当前包中还是在导入的包中的顶级标识符。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://golang.org/doc/faq"
            target="_blank"
        >
            https://golang.org/doc/faq
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>
<p>另外，如果你在使用go-lint工具，那么，在测试文件之外使用点导入时，它会显示一个警告，而且你无法轻易关闭它。</p>
<p>Go 团队推荐的一种使用情况是在测试中，由于循环依赖，不能成为被测包的一部分。依赖关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#75715e">// foo_test 包测试 foo 包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">foo_test</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bar/testutil&#34;</span> <span style="color:#75715e">// 也导入了 &#34;foo&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    . <span style="color:#e6db74">&#34;foo&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>这个测试文件不是 foo 包的一部分，因为它引用了 bar/testutil，而 bar/testutil 又引用了 foo。这将产生一个循环的依赖关系。</p>
<p>在这种情况下，首先要考虑的是，也许有一个更好的方法来结构这些包，以避免循环依赖性。
将 bar/testutil 使用的包从 foo 移到 foo 和 bar/testutil 都可以导入的第三个包中，可能有意义，也可能没有意义，这样就能在 foo 包中正常地编写测试。</p>
<p>如果重构没有意义，并且测试以点导入的方式被引用到独立包中，foo_test 包至少可以假装是 foo 包的一部分。但要注意的是，它不能访问 foo 包中未导出的类型和函数。</p>
<p>可以说，在特定领域的语言中，点导入有一个很好的用例。 例如，Goa 框架将其用于配置。如果没有点导入，它看起来就不是很好：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">design</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> . <span style="color:#e6db74">&#34;goa.design/goa/v3/dsl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// API 描述了 API 服务器的全局属性。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">API</span>(<span style="color:#e6db74">&#34;calc&#34;</span>, <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Title</span>(<span style="color:#e6db74">&#34;Calculator Service&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Description</span>(<span style="color:#e6db74">&#34;HTTP service for adding numbers, a goa teaser&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Server</span>(<span style="color:#e6db74">&#34;calc&#34;</span>, <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Host</span>(<span style="color:#e6db74">&#34;localhost&#34;</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">URI</span>(<span style="color:#e6db74">&#34;http://localhost:8088&#34;</span>) })
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-3-章-变量">第 3 章 变量</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="未使用的变量">未使用的变量</h2>
<p>含有未使用变量的 Go 程序无法编译：</p>
<blockquote>
<p>存在未使用的变量，表明可能存在一个错误[&hellip;]，Go 拒绝编译带有未使用的变量或包导入，以短期的便利保证长期的构建速度和程序的清晰度。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://golang.org/doc/faq"
            target="_blank"
        >
            https://golang.org/doc/faq
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>
<p>该规则的例外是全局变量和函数参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">unusedGlobal</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// 合法的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">unusedArg</span> <span style="color:#66d9ef">int</span>) { <span style="color:#75715e">// 未使用的函数声明也是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 错误: 定义但未使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里使用了 b ，但 a 只是分配给了，不算是 &#34;使用&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">b</span> 
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div><h2 id="短变量声明">短变量声明</h2>
<p>短变量声明只在函数中起作用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 错误: 在函数体外不能有声明语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v2</span> = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// 合法的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v3</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span> <span style="color:#75715e">// 合法的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v3</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在设置结构体字段值时，它们也不起作用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Field</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">myStruct</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 错误: 非名称的 s.Field在 := 的左侧。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Field</span>, <span style="color:#a6e22e">newVar</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">newVar</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Field</span>, <span style="color:#a6e22e">newVar</span> = <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#75715e">// 这实际上是合法的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="变量遮盖">变量遮盖</h2>
<p>令人遗憾的是，Go 中允许使用变量遮盖。这是你需要经常注意的事情，因为它可能导致难以发现的问题。
发生这种情况往往是图方便，在至少有一个变量是新的情况下，Go 允许使用短变量声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在这里 v1 实际上没有被重新声明，只是被设置了一个新的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span>) <span style="color:#75715e">// 打印 2, 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>然而，如果该声明是在另一个代码块内，它将声明一个新的变量，有可能导致严重的错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span>) <span style="color:#75715e">// 打印 2, 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>) <span style="color:#75715e">// 打印 1 !
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>对于一个更现实的例子，我们假设你有一个返回错误的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func1</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">errFunc1</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;important error&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">returnsErr</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">func1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errFunc1</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span>) <span style="color:#75715e">// 打印: 1 important error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span> <span style="color:#75715e">// 返回 nil!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">returnsErr</span>()) <span style="color:#75715e">// 打印 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>解决这个问题的办法很多，其中之一是不要在嵌套的代码块中使用短变量声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">returnsErr</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">func1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v1</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">errFunc1</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span>) <span style="color:#75715e">// 打印: 1 important error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span> <span style="color:#75715e">// 返回 &#34;important error&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>或者，相对于上面的例子，更好的做法是提前退出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">returnsErr</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">func1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errFunc1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">err</span>) <span style="color:#75715e">// 打印: 1 important error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也有一些工具可以帮助避免这个问题。在 go vet 工具中曾有实验性的变量遮盖检测，但它被删除了。
你可以输入如下命令来安装和运行该工具：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>go get -u golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow
</span></span><span style="display:flex;"><span>go vet -vettool<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>which shadow<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>打印：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>.<span style="color:#ae81ff">\m</span>ain.go:20:7: declaration of <span style="color:#e6db74">&#34;err&#34;</span> shadows declaration at line <span style="color:#ae81ff">17</span>
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-4-章-运算符">第 4 章 运算符</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="运算符优先级">运算符优先级</h2>
<p>Go的运算符优先级与其他语言不同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">优先级</span>        <span style="color:#a6e22e">运算符</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>            <span style="color:#f92672">*</span>, <span style="color:#f92672">/</span>, <span style="color:#f92672">%</span>, <span style="color:#f92672">&lt;&lt;</span>, <span style="color:#f92672">&gt;&gt;</span>, <span style="color:#f92672">&amp;</span>, <span style="color:#f92672">&amp;^</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>            <span style="color:#f92672">+</span>, <span style="color:#f92672">-</span>, |, ^
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>            <span style="color:#f92672">==</span>, <span style="color:#f92672">!=</span>, &lt;, <span style="color:#f92672">&lt;=</span>, &gt;, <span style="color:#f92672">&gt;=</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>            <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>            <span style="color:#f92672">||</span>
</span></span></code></pre></div><p>与 C 语言进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">优先级</span>        <span style="color:#a6e22e">运算符</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span>           <span style="color:#f92672">*</span>, <span style="color:#f92672">/</span>, <span style="color:#f92672">%</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>            <span style="color:#f92672">+</span>, <span style="color:#f92672">-</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>            <span style="color:#f92672">&lt;&lt;</span>, <span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>            &lt;, <span style="color:#f92672">&lt;=</span>, &gt;, <span style="color:#f92672">&gt;=</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>            <span style="color:#f92672">==</span>, <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>            <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>            ^
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>            |
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>            <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>            <span style="color:#f92672">||</span>
</span></span></code></pre></div><p>对于同一表达式，可能会产生不同结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">In</span> <span style="color:#a6e22e">Go</span>: <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// (1&lt;&lt;1)+1 = 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">In</span> <span style="color:#a6e22e">C</span>:  <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 1&lt;&lt;(1+1) = 4
</span></span></span></code></pre></div><h2 id="自增与自减">自增与自减</h2>
<p>Go 与许多其他语言不同，没有前缀自增或自减运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">++</span><span style="color:#a6e22e">i</span> <span style="color:#75715e">// 语法错误: 不期望 ++, 期望 }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">--</span><span style="color:#a6e22e">i</span> <span style="color:#75715e">// 语法错误: 不期望 --, 期望 }
</span></span></span></code></pre></div><p>虽然 Go 有这些运算符的后缀版本，但不允许在表达式中使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>] = <span style="color:#ae81ff">0</span> <span style="color:#75715e">// 语法错误: 不期望 ++, 期望:
</span></span></span></code></pre></div><h2 id="三目运算符">三目运算符</h2>
<p>Go 不支持三目运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span> <span style="color:#960050;background-color:#1e0010">?</span> <span style="color:#a6e22e">b</span> : <span style="color:#a6e22e">c</span>
</span></span></code></pre></div><p>在 Go 中这是不存在的，放弃吧。你必须使用 if-else 来代替三目运算符。
Go 语言的设计者认为这个运算符往往会导致难看的代码，最好不要有它。</p>
<h2 id="按位非">按位非</h2>
<p>在 Go 中，XOR 运算符 ^ 被用作一元 NOT 运算符，而不是像许多其他语言使用 ~ 符号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">In</span> <span style="color:#a6e22e">Go</span>: ^<span style="color:#ae81ff">1</span> <span style="color:#75715e">// -2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">In</span> <span style="color:#a6e22e">C</span>:  <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">// -2
</span></span></span></code></pre></div><p>二元 XOR 运算符仍被用作 XOR 运算符（异或）使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">3</span>^<span style="color:#ae81ff">1</span> <span style="color:#75715e">// 2
</span></span></span></code></pre></div>
    

    
        
    
        <h1 id="第-5-章-常量">第 5 章 常量</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="iota">iota</h2>
<p>在 Go 中，iota 是起始常量编号。 它并不像人们想象的那样意味着 &ldquo;从零开始&rdquo;。它是当前 const 块中一个常数的索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myconst</span> = <span style="color:#e6db74">&#34;c&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myconst2</span> = <span style="color:#e6db74">&#34;c2&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">two</span> = <span style="color:#66d9ef">iota</span> <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>使用两次 iota 并不能重置编号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">zero</span> = <span style="color:#66d9ef">iota</span> <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">one</span> <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">two</span> = <span style="color:#66d9ef">iota</span> <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-6-章-切片--数组">第 6 章 切片 &amp; 数组</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="切片和数组">切片和数组</h2>
<p>在 Go 中，切片和数组有类似的目的。它们的声明方式也几乎相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 让编译器来计算数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这将是一个等同于 [3]int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">array2</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">array2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>[1 2 3] [1 2 3] [1 2 3]
</code></pre><p>切片就像上层附带有用功能的数组。在实现过程中，他们在内部使用指向数组的指针。
但是，切片是如此的方便，以至于我们很少在 Go 中直接使用数组。</p>
<h2 id="数组">数组</h2>
<p>数组是固定长度内存的同类型序列。不同长度的数组被认为是不同的不兼容类型。
与 C 语言不同，Go 在创建数组时，数组元素被初始化为零值，因此，不需要明确地这样做。
同样，与 C 语言不同，Go 的数组是一种值类型。它不是一个指向内存块中第一个元素的指针。
如果把一个数组传入一个函数，整个数组将被复制。当然，仍然可以传递一个指向数组的指针来避免它被复制。</p>
<!-- raw HTML omitted -->
<h2 id="切片">切片</h2>
<p>切片是数组段的描述符。它是一个非常有用的数据结构，但可能有点不寻常。
有几种方法可以让你在使用它的时候踩坑，但如果你知道切片的内部工作原理，就可以避免踩这些坑。
下面是 Go 源代码中关于切片的实际定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>切片的定义十分有趣。切片本身是一个值类型，但是它用一个指针引用它所使用的数组。
与数组不同的是，如果你把一个切片传递给一个函数，你会得到一个数组指针、长度和容量属性的拷贝（上图中的第一个块），但数组本身的数据不会被复制。
两个切片的副本都会指向同一个数组。当你“切割”一个分片时，也会发生同样的事情。进行切割时，会创建一个新的切片，它仍然指向同一个数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 进行切割时，会产生一个新的切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 但不复制数组数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改子切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 也改变了主函数中切片的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f1&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将一个切片作为参数传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 复制切片的属性（指针、长度和容量）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 但该副本共享相同的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">f1</span>   [<span style="color:#ae81ff">13</span> <span style="color:#ae81ff">14</span>] <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span> [<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">13</span> <span style="color:#ae81ff">14</span> <span style="color:#ae81ff">5</span>] <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">5</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>如果你不知道切片是什么，你可能会认为它是一个值类型，并对 f1 “破坏”了主函数中切片的数据而感到惊讶。</p>
<h2 id="获得一个带有数据的切片副本">获得一个带有数据的切片副本</h2>
<p>为了得到一个带有数据的切片副本，你需要做一些工作。你可以手动复制元素到一个新的切片，或者使用复制或追加函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>    copy(<span style="color:#a6e22e">s2</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 或者如果你喜欢一个更简洁，但效率较低的版本：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// s2 := append([]int{}, s[2:4]...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s2</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f1&#34;</span>, <span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">f1</span>   [<span style="color:#ae81ff">13</span> <span style="color:#ae81ff">14</span>] <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span> [<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>] <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">5</span>
</span></span></code></pre></div><h2 id="用-append-扩容切片">用 append 扩容切片</h2>
<p>切片的所有副本都共享同一个数组，因此，如果对切片的捣乱，会对指针、长度和容量产生影响。除非他们不共享。
切片最有用的特性是它可以管理数组的扩容。当它需要扩容到超过现有数组的容量时，需要分配一个全新的数组。
如果你希望两份切片副本共享数组数据，这也可能是一个坑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 做一个长度为 3、容量为 4 的切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化为 1,2,3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 数组的容量是 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在初始数组中增加一个适合的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改数组中的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// s 和 s2 仍然共享同一个数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s2</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))    <span style="color:#75715e">// [11 12 13] 3 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>)) <span style="color:#75715e">// [11 12 13 14] 4 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这种扩容会使数组的容量增加，超过它的容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 必须为 s3 分配新的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> append(<span style="color:#a6e22e">s2</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改数组中的元素以查看结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s3</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s3</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// 依然是旧的数组 [11 12 13] 3 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>)) <span style="color:#75715e">// 旧数组 [11 12 13 14] 4 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 数组在最后一次扩容时被复制 [21 22 23 24 15] 5 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s3</span>, len(<span style="color:#a6e22e">s3</span>), cap(<span style="color:#a6e22e">s3</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<h2 id="nil-切片">nil 切片</h2>
<p>不需要检查切片是否为 nil，也不必将其初始化。因为，诸如 len、cap 和 append 等函数在一个 nil 切片上是可以正常工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">// nil 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// [] 0 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// [1] 1 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>空切片与 nil 切片不是一回事：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">// 这是一个 nil 切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{} <span style="color:#75715e">// 这是一个空切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在这里看起来是一回事:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// [] 0 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>)) <span style="color:#75715e">// [] 0 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 但 s2 实际上被分配到了某个地方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %p&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s2</span>) <span style="color:#75715e">// 0x0 0x65ca90
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>如果你非常关心性能、内存使用等问题，初始化空分片可能不如使用 nil 切片来得理想。</p>
<h2 id="make-的陷阱">make 的陷阱</h2>
<p>你可以使用 make 创建一个新切片，参数是切片的初始化类型、长度和容量。其中，容量参数是可选的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> make([]<span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span>) []<span style="color:#a6e22e">T</span>
</span></span></code></pre></div><p>这样做似乎有点太容易了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span>[<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>]
</span></span></code></pre></div><p>“不，这绝不会发生在我身上。我知道，对切片的第二个论据是长度，而不是容量&hellip;”我仿佛听到你这样说。</p>
<h2 id="未使用的切片数组数据">未使用的切片数组数据</h2>
<p>因为切割数组时，会创建一个新切片，但它们共享底层数组，所以有可能在内存中保留更多的数据，而这可能正是你想要或期望的。这里有一个愚蠢的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;io/ioutil&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getExecutableFormat</span>() []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将我们自己的可执行文件读入内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">bytes</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadFile</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bytes</span>[:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">format</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getExecutableFormat</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">format</span>, []byte(<span style="color:#e6db74">&#34;ELF&#34;</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;linux executable&#34;</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">HasPrefix</span>(<span style="color:#a6e22e">format</span>, []byte(<span style="color:#e6db74">&#34;MZ&#34;</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;windows executable&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，只要那个格式变量在范围内，且没被垃圾回收，那么整个可执行文件（可能是几兆字节的数据）就会被保留在内存中。
为了解决这个问题，应该复制实际需要的字节。</p>
<h2 id="多维切片">多维切片</h2>
<p>在 Go 中，目前还没有这样的东西。也许有一天会有，但目前为止，
你要么需要通过自己计算元素索引来手动将单维切片用作多维切片，
要么使用 &ldquo;锯齿状 &ldquo;切片（锯齿状切片是切片的切片）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span>[[<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>] [<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>] [<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>]]
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-7-章-字符串--字节数组">第 7 章 字符串 &amp; 字节数组</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="go-的字符串">Go 的字符串</h2>
<p>在 Go 中，字符串的定义是这样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringHeader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Len</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>字符串本身是值类型，包含一个指向字节数组的指针和一个固定的长度。与 C 语言不同，Go 字符串中的零字节并不标志着字符串的结束。
字符串里面可以包含任何数据。通常情况下，这些数据被编码为 UTF-8 字符串，但它不一定是这样。</p>
<h2 id="字符串不能为-nil">字符串不能为 nil</h2>
<p>在 Go 中，字符串永远不会为 nil。字符串的默认值是一个空字符串，而不是 nil：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#75715e">// 为真
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// 错误: 不能在赋值中使用 nil 作为字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="字符串是不可变的某种程度上">字符串是不可变的（某种程度上）</h2>
<p>Go 并不希望你修改字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;darkercorners&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">str</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;D&#39;</span> <span style="color:#75715e">// 错误: 不能分配给 str[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>不可变数据更易于推理，因此产生的问题更少。但缺点是，每次你想从一个字符串中添加或删除某些内容时，都必须分配一个全新的字符串。
如果你真的希望做些更改，可以通过 unsafe 包来修改字符串，但如果你真打算采用这种方式，可能就聪明过头了。</p>
<p>最常见情况是，当许多字符串需要加在一起时，你可能要担心分配的问题。
有一个 strings.Builder 类型用于解决这个问题，它在添加字符串时是批量分配内存，而不是每次都分配内存。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strconv&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkString</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">str</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkStringBuilder</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">i</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">BenchmarkString</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> <span style="color:#ae81ff">401053</span> <span style="color:#ae81ff">147346</span> <span style="color:#a6e22e">ns</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span> <span style="color:#ae81ff">1108686</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span> <span style="color:#ae81ff">2</span> <span style="color:#a6e22e">allocs</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">BenchmarkStringBuilder</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> <span style="color:#ae81ff">29307392</span> <span style="color:#ae81ff">44.9</span> <span style="color:#a6e22e">ns</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span> <span style="color:#ae81ff">52</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span> <span style="color:#ae81ff">0</span> <span style="color:#a6e22e">allocs</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>
</span></span></code></pre></div><p>在这个例子中，使用 strings.Builder 比简单的添加字符串（每次分配新的内存）要快3000倍。</p>
<p>在某些情况下，Go 编译器会优化掉这些分配：</p>
<ol>
<li>当把一个字符串和一个字节片相比较时：str == string(byteSlice)</li>
<li>当 []byte 被用于查找 map[string] 中的条目时：m[string(byteSlice)]</li>
<li>在字符串被转换为字节的 range 子句中：for i, v := range []byte(str) {&hellip;}</li>
</ol>
<p>Go 编译器的新版本可能会增加更多的优化，所以如果性能很重要，最好使用基准测试和分析器。</p>
<h2 id="字符串-vs-字节切片">字符串 vs 字节切片</h2>
<p>修改字符串的一种方法是首先将其转换为字节切片，然后再转换回字符串。
如下面的例子所示，将一个字符串转换为字节切片，然后再复制整个字符串和字节片。
原字符串并没有改变：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;darkercorners&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bytes</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bytes</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;D&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">str2</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">bytes</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bytes</span>[<span style="color:#ae81ff">6</span>] = <span style="color:#e6db74">&#39;C&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印: darkercorners Darkercorners DarkerCorners
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">str</span>, <span style="color:#a6e22e">str2</span>, string(<span style="color:#a6e22e">bytes</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用 unsafe 包，有可能（但显然是不安全的）直接修改字符串而不分配内存。</p>
<blockquote>
<p>导入 unsafe 包带来的结果可能是不可移植的，并且不受 Go 1 兼容性准则的保护。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://golang.org/pkg/unsafe/"
            target="_blank"
        >
            https://golang.org/pkg/unsafe/
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">&#34;darkercorners&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;D&#39;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 分配一个字符串，指向与 buf 字节切片相同的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buf</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改字节切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 现在它指向的是与字符串相同的内存。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里也对 str 进行了修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">6</span>] = <span style="color:#e6db74">&#39;C&#39;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// DarkerCorners DarkerCorners
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">str</span>, string(<span style="color:#a6e22e">buf</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="utf-8-的那些事儿">UTF-8 的那些事儿</h2>
<p>Unicode 和 UTF-8 是个棘手的问题。要了解 Unicode 和 UTF-8 的一般工作原理，你可能想阅读 Joel Spolsky 的博客
    <span class="link-wrapper">
        <a
            
            href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/"
            target="_blank"
        >
            《每个软件开发人员绝对必须知道的 Unicode 和字符集（没有借口！）》
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
。</p>
<p>做一个简短的回顾：</p>
<ol>
<li>Unicode 是 “一种用于不同语言和文字的国际编码标准，每个字母、数字或符号都被分配了一个独特的数值，适用于不同的平台和程序”。本质上，它是一个“码点”的大表。它包含了所有语言的大部分（但不是全部）字符。该表中，每个码位是一个索引，有时你可以看到用 U+ 符号指定，如 U+0041 表示字母 A。</li>
<li>通常，码位是指一个字符，例如汉字⻯（U+2EEF），但它也可以是一个几何形状或一个字符修饰符（例如德语 ä、ö 和 ü 等字母的音符）。出于某种原因，它甚至可以是一个便便图标（U+1F4A9）。</li>
<li>UTF-8 是将 Unicode 大表中的元素编码成计算机可以处理的实际字节的方法之一（也是最常见的一种）。</li>
<li>当用 UTF-8 编码时，单个的 Unicode 代码点可能需要 1 到 4 个字节。</li>
<li>数字和拉丁字母（a-z，A-Z，0-9）的编码为 1 个字节。许多其他语言的字母在 UTF-8 编码中需要 1 个以上的字节。</li>
<li>如果你不知道第 5 条，一旦有人用其他语言使用你的 Go 程序，你的程序可能会崩溃。当然，除非你仔细阅读了本章的其他内容。</li>
</ol>
<h2 id="go-中的字符串编码">Go 中的字符串编码</h2>
<p>Go 中的字符串是一个字节数组。任何字节，字符串本身不在意如何编码，也不必采用 UTF-8 编码。尽管有些库函数甚至是一种语言特性（for-range 循环，下文将介绍）假设它采用 UTF-8 编码。</p>
<p>认为 Go 字符串都是 UTF-8 的情况并不少见。但字符串的字面量给这种混乱带来了很大的影响。虽然字符串本身没有任何特定的编码，但 Go 编译器总是将源代码解释为 UTF-8。</p>
<p>当字符串的字面量被定义后，编辑器会把它同其他的代码一样，保存为 UTF-8 编码的 Unicode 字符串。这就是 Go 解析后会被编译到程序中的内容。无论是编译器还是 Go 的字符串处理代码，都与字符串最终被编码为 UTF-8 无关，这只是文本编辑器将字符串写入磁盘的方式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 一个含有 Unicode 字符的字符串字面量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;English 한국어&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印出预期的 Unicode 字符串: English 한국어
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了证明这一点，你可以这样定义一个非UTF-8的字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unicode/utf8&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;\xe2\x28\xa1&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">ValidString</span>(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// �(�
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="rune-类型">rune 类型</h2>
<p>在Go中，Unicode 码点用 “rune” 类型表示，它是一个 32 位的整数。</p>
<h2 id="字符串长度">字符串长度</h2>
<p>对字符串调用 len 函数，会返回字符串中的字节数，而不是字符数。</p>
<p>获取字符数可能是相当复杂的。计算字符串中的 rune 可能足够好，也可能不够好：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unicode/utf8&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;한국어&#34;</span> <span style="color:#75715e">// 3 个韩文字符，用 9 个字节编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">byteLen</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runeLen</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">RuneCountInString</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runeLen2</span> <span style="color:#f92672">:=</span> len([]rune(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// 做同 RuneCountInString 一样的事情
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">byteLen</span>, <span style="color:#a6e22e">runeLen</span>, <span style="color:#a6e22e">runeLen2</span>) <span style="color:#75715e">// 打印 9 3 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>不幸的是，有些 Unicode 字符跨越了多个码点，因此也有多个 rune。
正如 
    <span class="link-wrapper">
        <a
            
            href="http://unicode.org/reports/tr15/"
            target="_blank"
        >
            Unicode Standard
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
 中所解释的那样，需要做一些可怕的事情，才能计算出 Unicode 字符串中人类所感知的字符数。
Go 库并没有真正提供一个简单的方法来做到这一点。这里提供了一种解决方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unicode/utf8&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;golang.org/x/text/unicode/norm&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">normlen</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ia</span> <span style="color:#a6e22e">norm</span>.<span style="color:#a6e22e">Iter</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ia</span>.<span style="color:#a6e22e">InitString</span>(<span style="color:#a6e22e">norm</span>.<span style="color:#a6e22e">NFKD</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nc</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">ia</span>.<span style="color:#a6e22e">Done</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">nc</span> = <span style="color:#a6e22e">nc</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ia</span>.<span style="color:#a6e22e">Next</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nc</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;é́́&#34;</span> <span style="color:#75715e">// 一个特别奇怪的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;%d bytes, %d runes, %d actual character&#34;</span>,
</span></span><span style="display:flex;"><span>        len(<span style="color:#a6e22e">str</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">RuneCountInString</span>(<span style="color:#a6e22e">str</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">normlen</span>(<span style="color:#a6e22e">str</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>7 bytes, 4 runes, 1 actual character
</code></pre><h2 id="字符串索引操作符-vs-for-range">字符串索引操作符 vs for-range</h2>
<p>简而言之，对于字符串索引操作符，返回该字符串的字节数组中索引的字节。
对于 for-range，在一个字符串中对 rune 进行迭代，将字符串解释为 UTF-8 编码的文本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;touché&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印每个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// touchÃ©
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(string(<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>]))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印每个 rune
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// touché
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(string(<span style="color:#a6e22e">r</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将一个字符串转换为 rune 切片，以便通过索引访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// touché
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> []rune(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">r</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(string(<span style="color:#a6e22e">r</span>[<span style="color:#a6e22e">i</span>]))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-8-章-哈希">第 8 章 哈希</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="哈希的迭代顺序是随机的实则不然">哈希的迭代顺序是随机的（实则不然）</h2>
<p>技术上来说，哈希的迭代顺序是“未定义的”。在 Go 中，哈希的内部会使用一个哈希表，所以迭代通常是按照元素在该表中的顺序进行的。
但这个顺序是不可靠的，当新的元素被添加到哈希中时，这个顺序会随着哈希表的增长而改变。
在 Go 的早期时候，这对那些没有阅读说明，并且依赖按一定顺序迭代哈希的程序员来说，是一个巨坑。
为了帮助程序员尽早，而不是在生产中发现这些问题，Go 的开发者将哈希的迭代变得随机：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 添加顺序元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 使哈希看起来像是按顺序迭代的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>: <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>: <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>: <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>: <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">i</span>, <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 添加更多元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 使哈希的哈希表增长并重新排序元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">6</span>] = <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">7</span>] = <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">8</span>] = <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">i</span>, <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">8</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">8</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">8</span>
</span></span></code></pre></div><p>在上面的例子中，当哈希被初始化时，元素 1 到 5 被按顺序添加到哈希表中。
前五行打印的数字都是按顺序写的 0 到 5。在 Go 中，这只是随机从某个元素开始迭代。
向哈希中添加更多的元素会使哈希表增长，从而重新排列整个哈希表的顺序。
打印最后 5 行时，就不再有任何明显的顺序。如果必要，你可以在 
    <span class="link-wrapper">
        <a
            
            href="https://github.com/golang/go/blob/master/src/runtime/map.go"
            target="_blank"
        >
            Go 的 Map 源代码
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
 中找到所有的信息。</p>
<h2 id="检查哈希的键是否存在">检查哈希的键是否存在</h2>
<p>访问哈希中不存在的元素时，会返回哈希值类型的零值。如果是一个整型的哈希，它将返回 0，对于引用类型，它将返回 nil。
为了检查元素是否存在于哈希中，有时一个零值就足够了。
例如，如果是一个值类型为指向结构体的指针的哈希，那么在访问哈希时，如果得到一个 nil 值，这意味着你寻找的元素不在哈希中。
但是，如果是一个值类型为布尔值的哈希，因为默认零值为“false”，所以它不足以判断元素的值为“false”，还是元素根本不存在于哈希中。
因此，访问哈希元素时，会返回一个可选的第二参数，以显示该元素是否真的在哈希中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>{<span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">2</span>: <span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">3</span>: <span style="color:#66d9ef">true</span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印为 false 时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 不清楚该元素的值是 false，或者哈希中不存在此元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因为返回的默认零值为 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">exists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">exists</span>) <span style="color:#75715e">// 打印 false true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="哈希是指针">哈希是指针</h2>
<p>虽然切片类型是一个结构体（值类型），它有一个指向数组的指针，但哈希本身就是一个指针。
切片的零值完全是可用的。你可以使用 append 函数来添加元素，也可以获得切片的长度。
而哈希则不同，尽管 Go 的开发者希望让哈希的零值完全可用，但没找到有效的途径来实现这一点。
在 Go 中，map 关键字是 *runtime.hmap 类型的别名。它的零值是 nil，nil 哈希可以被读取，但不能被写入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span> <span style="color:#75715e">// 一个 nil 哈希
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 读取 nil 哈希的长度是可以的，打印 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">m</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读取 nil 哈希也是确定的，打印 0（哈希的值类型的默认值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">10</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">10</span>] = <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 警告: 分配内存给 nil 哈希中的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>nil 哈希可以被读取，因为哈希的元素是通过像这样的函数（来自 runtime/map.go）来访问的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mapaccess1</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">maptype</span>, <span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span>, <span style="color:#a6e22e">key</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span></code></pre></div><p>这个函数检查哈希是否为 nil，如果是，则返回哈希值类型的零值。注意，它不能创建一个哈希。如果要创建完全可用的哈希，必须使用 make：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">10</span>] = <span style="color:#ae81ff">11</span>         <span style="color:#75715e">// 现在就都没问题了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">10</span>]) <span style="color:#75715e">// 打印 11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>由于哈希是指针，把它传递给函数时，就会传递指向同一个 map 数据结构的指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">5</span>] = <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">5</span>]) <span style="color:#75715e">// 打印 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>当哈希的指针被传递给函数时，指针的值会被复制（Go 通过值传递一切，包括指针）。在函数中创建一个新的哈希会改变指针副本的值，所以这是不可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">5</span>] = <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">5</span>])     <span style="color:#75715e">// 打印 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="struct-类型">struct{} 类型</h2>
<p>在 Go 中，没有集合这个数据结构（类似于有键但无值的哈希，如 C++ 的 std::set 或 C# 的 HashSet）。
使用哈希来代替是很容易的。一个小技巧是使用 struct{} 类型作为哈希值类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">123</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">keyexists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">123</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">keyexists</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>通常，这里会使用布尔值，但如果使用 struct{} 值类型的哈希会节省一点内存。struct{} 类型实际上就是零字节大小：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#66d9ef">false</span>)) <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#66d9ef">struct</span>{}{})) <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="哈希的容量">哈希的容量</h2>
<p>哈希是一个相当复杂的数据结构。虽然在创建它时，可以指定它的初始容量，但之后就不可能得到它的容量了（至少不能用 cap 函数）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>, <span style="color:#ae81ff">5</span>) <span style="color:#75715e">// 初始化容量为 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">m</span>)) <span style="color:#75715e">// len 函数是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(cap(<span style="color:#a6e22e">m</span>)) <span style="color:#75715e">// 对于 cap 函数来说，m (map[int]bool 类型) 是非法参数 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="哈希值是不可寻址的">哈希值是不可寻址的</h2>
<p>在 Go 中，哈希是以哈希表的形式实现的，而哈希表需要在哈希增长或缩小时移动其元素。由于这个原因，Go 不允许获取哈希元素的地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#a6e22e">item</span>{<span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;one&#34;</span>}}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">value</span>) <span style="color:#75715e">// 读取结构值是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>]           <span style="color:#75715e">// 错误: 无法读取 m[1] 的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 错误: 在哈希中，不能赋值给结构体字段 m[1].value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">value</span> = <span style="color:#e6db74">&#34;two&#34;</span>      
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有一个 
    <span class="link-wrapper">
        <a
            
            href="https://github.com/golang/go/issues/3117"
            target="_blank"
        >
            允许赋值给一个结构体字段的提议
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
（m[1].value = &ldquo;two&rdquo;），因为在这种情况下，只通过赋值，值字段的指针不会被保留。
但由于 &ldquo;subtle corner cases&rdquo;，目前还没有具体计划关于此提议何时或是否会实施。</p>
<p>有一种变通方法，但整个结构体需要重新被分配到哈希中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#a6e22e">item</span>{<span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;one&#34;</span>}}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">value</span> = <span style="color:#e6db74">&#34;two&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">tmp</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，指向结构体的指针映射也可以成功。在这种情况下，m[1] 的值是一个 *item 类型。
Go 不需要获取指向映射值的指针，因为该值本身已经是指针了。
哈希表会在内存中移动指针，但是如果你复制一个 m[1] 的值，它将一直指向同一个元素，所以这也是一样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">item</span>{<span style="color:#ae81ff">1</span>: {<span style="color:#e6db74">&#34;one&#34;</span>}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Go 在这里不需要访问 m[1] 的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因为它已经是指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">value</span> = <span style="color:#e6db74">&#34;two&#34;</span>      
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">value</span>) <span style="color:#75715e">// two
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>] <span style="color:#75715e">// 同样的错误: 不能访问 m[1] 的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>值得注意的是，切片和数组不存在这个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;one&#34;</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">saddr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">saddr</span> = <span style="color:#e6db74">&#34;two&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice</span>) <span style="color:#75715e">// [two]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="数据竞争">数据竞争</h2>
<p>在 Go 中，普通哈希对于并发访问并不安全。哈希经常被用来在 goroutine 之间共享数据，
但对哈希的访问必须通过 sync.Mutex、sync.RWMutex，其他内存锁进行同步，或者与 Go 的通道协调以防止并发访问，但以下情况除外：</p>
<blockquote>
<p>只有当更新发生时，哈希访问才是不安全的。只要所有的 goroutine 只是在阅读查找哈希中的元素，包括使用 for-range 循环遍历哈希，
而不是通过向元素赋值或进行删除来改变哈希，那么它们在不同步的情况下并发访问哈希就是安全的。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://golang.org/doc/faq"
            target="_blank"
        >
            https://golang.org/doc/faq
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">readWrite</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对哈希做一些随机的读和写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">k</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 启动 goroutine 来同时读写哈希
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">readWrite</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>致命错误: 同时进行的哈希读取和写入
致命错误: 同时进行的哈希写入
...
</code></pre><p>在这种情况下，可以使用 Mutex 同步访问哈希。下面的代码将按预期工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">readWrite</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// defer unlock mutex 将解锁 mutex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 即使这个 goroutine 会警告
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">k</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">readWrite</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="syncmap">sync.Map</h2>
<p>在 sync 包中，哈希有一个专门版本，对于多个 goroutine 的并发使用是安全的。
然而 Go 文档建议在大多数情况下使用带有锁或者协调的普通哈希。
因为 sync.Map 不是类型安全的，它类似于 map[interface{}]interface{}。如 sync.Map 文档所说：</p>
<blockquote>
<p>哈希类型针对两种常见的使用情况进行了优化：
(1)当一个给定键的条目只被写入一次，但被多次读取，就像在只会增长的缓存中，
或者(2)当多个 goroutine 读取、写入和覆盖不相干的键集的条目时。
在这两种情况下，与 Go 中的普通哈希搭配单独的 Mutex 或 RWMutex 相比，使用 sync.map 可以大大减少锁争用。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://github.com/golang/go/blob/master/src/sync/map.go"
            target="_blank"
        >
            https://github.com/golang/go/blob/master/src/sync/map.go
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>

    

    
        
    
        <h1 id="第-9-章-循环">第 9 章 循环</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="range-迭代器会返回两个值">range 迭代器会返回两个值</h2>
<p>由于 for-range 的工作方式与其他语言不尽相同，对于 Go 的初学者来说，这很可能是一个坑。
for-range 会返回一个或两个变量，第一个是迭代索引（如果是迭代哈希，则是哈希键），第二个是值。如果只使用一个变量——那它就是索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;one&#34;</span>, <span style="color:#e6db74">&#34;two&#34;</span>, <span style="color:#e6db74">&#34;three&#34;</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>) <span style="color:#75715e">// 0, 1, 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>) <span style="color:#75715e">// one two three
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="for-循环会重复使用迭代器变量">for 循环会重复使用迭代器变量</h2>
<p>在循环中，每次迭代都会重复使用同一个迭代器变量。如果你读取它的地址，那每次都是同一个地址。
这意味着在每次迭代中，迭代器变量的值都会被复制到同一个内存位置。这使得循环更有效率，但也是 Go 最常见的陷阱之一。
下面是 Go wiki 中的一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">out</span> []<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">out</span> = append(<span style="color:#a6e22e">out</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Values:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">0</span>], <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">1</span>], <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Addresses:&#34;</span>, <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">Values</span>: <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Addresses</span>: <span style="color:#ae81ff">0xc0000120e0</span> <span style="color:#ae81ff">0xc0000120e0</span> <span style="color:#ae81ff">0xc0000120e0</span>
</span></span></code></pre></div><p>惊讶吧，不过有一个解决方案，是在循环中声明一个新的变量。在代码块中声明的变量不会被重复使用，即使在循环中也是如此：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">out</span> []<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#75715e">// 将 i 复制到一个新的变量中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">out</span> = append(<span style="color:#a6e22e">out</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Values:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">0</span>], <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">1</span>], <span style="color:#f92672">*</span><span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Addresses:&#34;</span>, <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">out</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，它就可以像预期的那样运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">Values</span>: <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Addresses</span>: <span style="color:#ae81ff">0xc0000120e0</span> <span style="color:#ae81ff">0xc0000120e8</span> <span style="color:#ae81ff">0xc0000120f0</span>
</span></span></code></pre></div><p>如果是 for-range 子句，则会重复使用索引变量和值变量。</p>
<p>这与在一个循环中启动 goroutine 的情况类似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">333</span>
</span></span></code></pre></div><p>这些 goroutine 是在这个循环中创建的，但它们需要一点时间来开始运行。
由于它们捕获的是单个 i 变量，因此，Println 会打印 goroutine 执行时的任何值。</p>
<p>在这种情况下，可以像之前的例子那样，在代码块内创建一个新的变量，或者把迭代器变量作为参数传递给 goroutine：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>        }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">012</span>
</span></span></code></pre></div><p>这里，goroutine 的参数 i 是一个新变量，它作为创建 goroutine 时的一部分，从迭代器变量中复制过来的。</p>
<p>如果不启动 goroutine，而是在循环中调用一个简单的函数，代码就会像预期的那样工作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">012</span>
</span></span></code></pre></div><p>变量 i 像以前一样被重复使用。然而，直到函数执行完毕，并不是每个函数调用都会让循环继续。在那段时间里，变量 i 会有预期值。</p>
<p>这就变得有点棘手了。请看这个例子，在结构体上调用方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span>) <span style="color:#a6e22e">myMethod</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打印 myStruct 的值和它的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v, %p\n&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">byValue</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">myStruct</span>{{<span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">2</span>}, {<span style="color:#ae81ff">3</span>}}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">byReference</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span>{{<span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">2</span>}, {<span style="color:#ae81ff">3</span>}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;By value&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">byValue</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">myMethod</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;By reference&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">byReference</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">myMethod</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">By</span> <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0xc000012120</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0xc000012120</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0xc000012120</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">By</span> <span style="color:#a6e22e">reference</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xc0000120e0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0xc0000120f0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0xc0000120e8</span>
</span></span></code></pre></div><p>再次惊讶吧！当 myStruct 采用引用类型时，它的运行起来就像一开始就没有陷阱一样！
这与 goroutine 的创建方式有关，在 goroutine 被创建时，goroutine 的参数会被评估。
方法接收器（myMethod 的 myStruct）实际上是一个参数。</p>
<p>当通过值类型调用时：由于 myMethod 的参数 s 是一个指针，i 的地址被作为参数传给 goroutine。
正如我们所知，迭代器变量是重复使用的，所以每次都是同一个地址。
当迭代器运行时，它将复制一个新的 myStruct 值到 i 变量的同一地址。打印的值是在 goroutine 执行时 i 变量的值。</p>
<p>当通过引用类型调用时：参数已经是一个指针，所以在创建 goroutine 时，它的值被推到新 goroutine 的堆栈中。这恰好是我们想要的地址，这样预期值就被打印出来了。</p>
<h2 id="带标签的-break-和-continue">带标签的 break 和 continue</h2>
<p>在 Go 中，也许还有一些不太为人所知的特点，比如能够给 for、switch 和 select 语句打上标签，并在这些标签上使用 break 和 continue。
下面是如何跳出外循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">loopi</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">y</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loopi</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>continue 也可以以类似的方式使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">loopi</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">y</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">y</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">loopi</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>标签也可以与 switch 和 select 语句一起使用。在这里，没有标签的 break 只会跳出 select 语句，进入 for 循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">loop</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;timeout reached&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;the end&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">timeout</span> <span style="color:#a6e22e">reached</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">the</span> <span style="color:#a6e22e">end</span>
</span></span></code></pre></div><p>如前所述，switch 和 select 语句也可以被标记，所以我们可以把上面的例子转过来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">myswitch</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">true</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;switch&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">myswitch</span> <span style="color:#75715e">// 在这种情况下，就不必执行 &#34;continue&#34; 了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;the end&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在前面的例子中，我们很容易将 “label 语句” 与 goto 所使用的标签混淆。实际上，你可以为 break/continue 和 goto 使用同一个标签，但行为会有所不同。
在下面的代码中，break 会跳出一个有标签的循环，而 goto 会将执行转移到标签的位置（并在下面代码中，导致无限循环）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">loop</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">true</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;switch&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">loop</span> <span style="color:#75715e">// 跳出 “label 语句”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;not the end&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">loop</span> <span style="color:#75715e">// 跳入带有 “loop” 标签的语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>switch
not the end
switch
not the end
...
</code></pre>
    

    
        
    
        <h1 id="第-10-章-switch--select-语句">第 10 章 switch &amp; select 语句</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="case-语句默认为断句">case 语句默认为断句</h2>
<p>与 C 语言的 case 语句不同，Go 中的 case 语句默认为中断。要使 case 语句通过，请使用 fallthrough 关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这样无法运行，如果是 Saturday 情况，那什么都不会被打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>: <span style="color:#75715e">// 这种情况下，不会做任何事情，并跳出 switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;weekend&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span> <span style="color:#75715e">// 这个 break 没有任何作用，因为无论如何都会跳出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;weekend&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fallthrough 关键字将使 Saturday 同样也打印 weekend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">fallthrough</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;weekend&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// case 也可以有多个值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;weekend&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 条件性中断仍然是可用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">day</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Format</span>(<span style="color:#e6db74">&#34;01-02&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;12-25&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;12-26&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Christmas weekend&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#75715e">// 不会打印 &#34;weekend&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 一个正常的 weekend
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;weekend&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="带标签的断点">带标签的断点</h2>
<p>正如之前在循环的章节中提到的，switch 和 select 也可以利用带标记的 break 来跳出外循环，而不是 switch 或 select 语句本身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;The quick brown Waldo fox jumps over the lazy dog&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">findWaldoLoop</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34; &#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">w</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Waldo&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;found Waldo!&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> <span style="color:#a6e22e">findWaldoLoop</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;is not Waldo&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">The</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">Waldo</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">quick</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">Waldo</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">brown</span> <span style="color:#a6e22e">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">Waldo</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">found</span> <span style="color:#a6e22e">Waldo</span>!
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-11-章-函数">第 11 章 函数</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="defer-语句">defer 语句</h2>
<p>defer 似乎没有大坑，但有一些细微差别是值得一提的。</p>
<p>关于这个问题，有一篇来自 Andrew Gerrand 的 
    <span class="link-wrapper">
        <a
            
            href="https://go.dev/blog/defer-panic-and-recover"
            target="_blank"
        >
            好文章
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
：</p>
<blockquote>
<p>defer 语句会将其包涵的递延函数推到一个调用列表上，
保存的调用列表将在原函数返回后被执行。
因此，defer 通常被用来简化执行各种清理动作的函数。</p>
</blockquote>
<p>但是，有几点是需要特别注意的：</p>
<ol>
<li><strong>虽然递延函数在原函数返回时才会被执行，但其参数也会在调用 defer 时被使用</strong>：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;defer&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = <span style="color:#e6db74">&#34;original&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">original</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span>
</span></span></code></pre></div><ol start="2">
<li><strong>一旦原函数返回，递延函数就按后进先出的顺序执行</strong>：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;one&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;two&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;three&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">three</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">two</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">one</span>
</span></span></code></pre></div><ol start="3">
<li><strong>递延函数可以访问和修改函数中已命名的参数</strong>：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">timeNow</span>() (<span style="color:#a6e22e">t</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">t</span> = <span style="color:#e6db74">&#34;Current time is: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Format</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Stamp</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">timeNow</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#a6e22e">Current</span> <span style="color:#a6e22e">time</span> <span style="color:#a6e22e">is</span>: <span style="color:#a6e22e">Feb</span> <span style="color:#ae81ff">13</span> <span style="color:#ae81ff">13</span>:<span style="color:#ae81ff">36</span>:<span style="color:#ae81ff">44</span>
</span></span></code></pre></div><ol start="4">
<li><strong>defer 对代码块不起作用，只对整个函数起作用</strong></li>
</ol>
<p>与变量声明不同，defer 语句不属于代码块的范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">9</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">%</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;defer&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>            }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;exiting main&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>exiting main
defer 6
defer 3
defer 0
</code></pre><p>在这个例子中，当 i 为 0、3 和 6 时，递延函数将被添加到调用列表中。但它只有在主函数退出时才会被调用，而不是在 if 语句结束时。</p>
<ol start="5">
<li><strong>recover() 函数只在递延函数中起作用，在原函数中不会做任何事情</strong></li>
</ol>
<p>在 Go 中，如果你想找一个与 try-catch 语句相当的语句，可以肯定这是没有的。想要捕获 panic 的内容，需要在递延函数中使用 recover()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">panickyFunc</span>() {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#e6db74">&#34;panic!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover()
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;recovered&#34;</span>, <span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panickyFunc</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;this will never be printed&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>recovered panic!
</code></pre>
    

    
        
    
        <h1 id="第-12-章-协程">第 12 章 协程</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="什么是-goroutine">什么是 goroutine</h2>
<p>通常情况下，goroutine 可以被认为是轻量级线程。goroutine 的启动非常快速，因为仅需要使用 2kb 内存就可以初始化堆栈（当然，也可以改动）。
goroutine 由 Go 的运行时系统管理（而不是操作系统），因此，在上下文切换的代价很低。
goroutine 就是为并发而生的，即使在多个硬件的线程上运行，它们也可以并行。</p>
<blockquote>
<p>并发是指同时处理很多事情；并行是指同时做很多事情。</p>
<p>Rob Pike</p>
</blockquote>
<p>goroutine 的效率是非常之高的，如果与 channel 相结合，它们很可能是 Go 的最佳功能。
尽管 goroutine 在 Go 中是无处不在的，但也存在一个极端但很好的例子。
当一个服务器管理大量并发的 websocket 连接时，goroutine 需要分别被单独管理，但更多可能是处于闲置状态的（不占用很多 CPU 或内存）。
为每个连接都创建一个线程，一旦连接数变得数以千计就会出现问题，然而，在使用 goroutine 时，产生数十万的连接也是可能的。</p>
<p>关于 goroutine 是如何工作的，可以 
    <span class="link-wrapper">
        <a
            
            href="https://medium.com/technofunnel/understanding-golang-and-goroutines-72ac3c9a014d"
            target="_blank"
        >
            在这里
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
 找到更详细的帖子。</p>
<h2 id="运行-goroutine-并不能阻止程序退出">运行 goroutine 并不能阻止程序退出</h2>
<p>在 Go 中，当主函数退出时，程序也就退出了。此时，任何在后台运行的 goroutine 都会安静地停止。
下面的程序将退出，且不打印任何东西：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine1</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;goroutine1&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine2</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;goroutine2&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">goroutine1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">goroutine2</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了确保这些 goroutine 可以完成，需要添加一些同步，例如使用通道或 sync.WaitGroup：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine1</span>(<span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;goroutine1&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine2</span>(<span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;goroutine2&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">goroutine1</span>(<span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">goroutine2</span>(<span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：（该结果可能会颠倒）</p>
<pre tabindex="0"><code>goroutine2
goroutine1
</code></pre><h2 id="goroutine-报警会使整个程序崩溃">goroutine 报警会使整个程序崩溃</h2>
<p>在 goroutine 内部发生的报警时，必须用 defer 和 recover() 来处理。否则，整个应用程序将崩溃：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goroutine1</span>() {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#e6db74">&#34;something went wrong&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">goroutine1</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;will never get here&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>panic: something went wrong 

goroutine 18 [running]:
main.goroutine1()
        c:/projects/test/main.go:9 +0x45
created by main.main
        c:/projects/test/main.go:13 +0x45
</code></pre>
    

    
        
    
        <h1 id="第-13-章-接口">第 13 章 接口</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="检查接口变量是否为-nil">检查接口变量是否为 nil</h2>
<p>在 Go 中，接口当然是最常见的坑之一。但与其他语言不同，Go 的接口不只是一个指向内存位置的指针。</p>
<p>一个接口类型的结构有：</p>
<ul>
<li>静态类型（接口本身的类型）</li>
<li>动态类型</li>
<li>值</li>
</ul>
<blockquote>
<p>如果一个变量为接口类型，当它的动态类型和值都为 nil 时，那它就等于 nil。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ISayHi</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SayHi</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#a6e22e">Say</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里，变量 &#34;sayer&#34; 只具有静态类型的 ISayHi。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 动态类型和值都是 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayer</span> <span style="color:#a6e22e">ISayHi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 果然，Sayer 等于 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sayer</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 一个具体类型，但值为 nil 的变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayerImplementation</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 接口变量的动态类型现在是 SayHi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 接口指向的实际值仍然为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sayer</span> = <span style="color:#a6e22e">sayerImplementation</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// sayer 不再等于 nil，因为它的动态类型已经被设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 即使它所指向的值为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里并不是大多数人所期望的那样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sayer</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>接口值被设置为一个 nil 结构体时，不能用来做任何事情，那么为什么它不等于nil呢？
与其他语言相比，这便是 Go 的另一个不同之处。在 C# 中，对一个 nil 类调用方法会抛出一个异常，但在 Go 中，无论怎样，这都是允许的。
因此，当接口设置了动态类型时，即使值为 nil，有时也可以使用。所以，你可以说接口并不是真的是 &ldquo;nil&rdquo;：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ISayHi</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SayHi</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#a6e22e">Say</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这个函数并没有访问 s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 即使 s 为 nil，这也会正常执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayer</span> <span style="color:#a6e22e">ISayHi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayerImplementation</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sayer</span> = <span style="color:#a6e22e">sayerImplementation</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在 sayer 接口中，SayHi 的值为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在 Go 中，可以对一个 nil 结构体调用方法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这行可以正常运行，因为 Say 函数并没有访问s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sayer</span>.<span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>尽管这可能很奇怪，但没有简单的方法可以用来检查一个接口指向的值是否为 nil。
关于这个问题，有一个长期的讨论，但似乎并没有什么进展。所以在近期，你可以做这些事情：</p>
<h3 id="弊端最少的选择-1永远不要给接口分配值为-nil-的具体类型">弊端最少的选择 #1：永远不要给接口分配值为 nil 的具体类型</h3>
<p>如果你从不给接口变量分配值为 nil 的具体类型（除非是那些被设计为与 nil 接收器一起工作的类型），那么简单的 &ldquo;==nil&rdquo; 判断将总是有效。
例如，永远不要这样做：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MyFunc</span>() <span style="color:#a6e22e">ISayHi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sunday</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">result</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SayHi</span>{}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果不是 Sunday，则返回一个不等于 nil 的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 但其具体类型的值为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// (MyFunc() == nil 将是 false)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而应该返回一个实际的 nil：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MyBetterFunc</span>() <span style="color:#a6e22e">ISayHi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Weekday</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sunday</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果不是 Sunday
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// MyBetterFunc() == nil 将是 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SayHi</span>{}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>即使这并不理想，但它可能是现有的最好的解决方案，因为那时每个人都必须意识到它的存在，然后，并在代码审计等方面进行监控。
在某种程度上，这是在做计算机可以完成的工作。</p>
<h3 id="特殊情况下的选择-2反射">特殊情况下的选择 #2：反射</h3>
<p>如果必要，你可以通过反射来检查一个接口的底层值是否为 nil。
这可能不是一个好主意，如果你的代码总是调用这些函数，程序会变得很慢：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsInterfaceNil</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rvalue</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rvalue</span>.<span style="color:#a6e22e">Kind</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">Ptr</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">rvalue</span>.<span style="color:#a6e22e">IsNil</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>检查 Kind() 的值是否为指针是必要的，因为如果类型为 nil（如简单的 int），IsNil 会报警。</p>
<h3 id="请不要做这个选择-3在你的结构接口中添加-isnil">请不要做这个选择 #3：在你的结构接口中添加 IsNil</h3>
<p>这样做，你可以在不使用反射的情况下检查一个接口是否为 nil：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ISayHi</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IsNil</span>() <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SayHi</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#a6e22e">Say</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#a6e22e">IsNil</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="也许应该考虑-1-和-4断言具体类型">也许应该考虑 #1 和 #4：断言具体类型</h3>
<p>如果你知道接口值应该是什么类型，你可以通过类型转换或类型断言，这样，先得到一个具体类型的值，再来检查它是否为nil：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MyFunc</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果你真的知道自己在做什么，这也许是好的，但在很多情况下，这就违背了使用接口的初衷。
考虑一下，当 ISayHi 的新实现被添加进来时会发生什么。你是否需要记得去寻找这段代码，并为新结构体添加另一个检查？你会对每个新的实现都这样做吗？
如果这段代码是在处理一个很少发生的事件，且没有对新添加的实现进行检查，而是在代码进入生产后很久才注意到的，那该怎么办？</p>
<h2 id="接口是隐性满足的">接口是隐性满足的</h2>
<p>与许多其他语言不同，你不需要明确说明一个结构实现了一个接口。编译器可以自己解决这个问题。这有很大的意义，而且在实践中非常方便：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ISayHi</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这个结构体实现了 ISayHi，即使不知道存在 ISayHi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SayHi</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>) <span style="color:#a6e22e">Say</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayer</span> <span style="color:#a6e22e">ISayHi</span> <span style="color:#75715e">// sayer 是一个 interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sayer</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SayHi</span>{} <span style="color:#75715e">// SayHi 隐式地实现了 ISayHi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sayer</span>.<span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有时，让编译器检查一个结构是否实现了一个接口是很有用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#75715e">// 在编译时验证 *SayHi 是否实现了 ISayHi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">ISayHi</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi</span>)(<span style="color:#66d9ef">nil</span>)
</span></span></code></pre></div><h2 id="对错误的类型进行类型断言">对错误的类型进行类型断言</h2>
<p>类型断言有单变量和双变量版本。当类型不是被断言的类型时，单变量版本会报警：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sayer</span> <span style="color:#a6e22e">ISayHi</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">sayer</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">SayHi</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// t 是一个类型为 *SayHi2 的零值（本例中为 nil）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// ok 将会是 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sayer</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi2</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 警告: 接口转换:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// main.ISayHi 是 *main.SayHi，而不是 *main.SayHi2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">t2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sayer</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">SayHi2</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">t2</span>.<span style="color:#a6e22e">Say</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-14-章-继承">第 14 章 继承</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="重定义类型-vs-嵌入类型">重定义类型 vs 嵌入类型</h2>
<p>Go 的类型系统可能更加实用。它不像 C++ 或 Java 那样是面向对象的。在 Go 中，你不能真正地继承结构体或接口（因为没有子类），但你可以把它们放在一起（嵌入），形成更复杂的结构体或接口。</p>
<blockquote>
<p>嵌入与子类有一个重要的不同之处：当我们嵌入一个类型时，该类型的方法会成为外类型的方法；但是当它们被调用时，方法的接收者是内类型，而不是外类型。</p>
<p>
    <span class="link-wrapper">
        <a
            
            href="https://golang.org/doc/effective_go"
            target="_blank"
        >
            https://golang.org/doc/effective_go
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
</p>
</blockquote>
<p>除了嵌入类型，Go 还允许重新定义一个类型。 重定义会继承一个类型的字段，但没有继承其方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">t1</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f1</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">t1</span>) <span style="color:#a6e22e">t1method</span>() {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 嵌入类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">t2</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 重定义类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">t3</span> <span style="color:#a6e22e">t1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mt1</span> <span style="color:#a6e22e">t1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mt2</span> <span style="color:#a6e22e">t2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mt3</span> <span style="color:#a6e22e">t3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 字段在所有情况下都会被继承
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">mt1</span>.<span style="color:#a6e22e">f1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">mt2</span>.<span style="color:#a6e22e">f1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">mt3</span>.<span style="color:#a6e22e">f1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 正常运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mt1</span>.<span style="color:#a6e22e">t1method</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mt2</span>.<span style="color:#a6e22e">t1method</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// mt3.t1method 未定义（t3 类型没有字段或者 t1method 方法）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mt3</span>.<span style="color:#a6e22e">t1method</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-15-章-平等性">第 15 章 平等性</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="go-的平等性">Go 的平等性</h2>
<p>在 Go 中，有很多不同的方法来比较平等性，但没有一个是完美的。</p>
<h2 id="-和--操作符">== 和 != 操作符</h2>
<p>在 Go 中，== 运算符是最简单、最有效的比较方法，但它只对某些类型有效。
最值得注意的是，它对切片或哈希不起作用。如果采用这种方式，切片和哈希只能与 nil 进行比较。</p>
<p>你可以使用 == 比较基本类型，如 int 和 string，还有数组和结构体中的元素本身也可以使用 == 进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">compareStruct1</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">compareStruct1</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">compareStruct1</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s2</span>) <span style="color:#75715e">// 正常运行，打印 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在结构体中，一旦添加了一个不能使用 == 比较的属性，就需要用另一种方式来比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">compareStruct2</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">// 将 C 的类型从数组改为切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">compareStruct2</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">compareStruct2</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 无效操作: s1 == s2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// (包含 []int 的结构体不能被比较)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="编写专门的比较代码">编写专门的比较代码</h2>
<p>如果性能很重要，而且需要比较稍微复杂的类型，最好的选择可能是手写比较代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">compareStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">compareStruct</span>) <span style="color:#a6e22e">Equals</span>(<span style="color:#a6e22e">s2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">compareStruct</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">A</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">A</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">B</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">B</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">C</span>) <span style="color:#f92672">!=</span> len(<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">C</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">C</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">C</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">C</span>[<span style="color:#a6e22e">i</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>像上面代码中的比较函数可以自动生成，但在写这篇文章时，我还不知道有什么工具可以做到这一点。</p>
<h2 id="reflectdeepequal">reflect.DeepEqual</h2>
<p>在 Go 中，DeepEqual 是最通用的比较方法，它可以处理大部分平等性比较。但这里有一个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c1</span> = <span style="color:#a6e22e">compareStruct</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">B</span>: <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">C</span>: []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c2</span> = <span style="color:#a6e22e">compareStruct</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">B</span>: <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">C</span>: []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkManual</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c1</span>.<span style="color:#a6e22e">Equals</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c2</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkDeepEqual</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">c1</span>, <span style="color:#a6e22e">c2</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>BenchmarkManual-8 217182776 5.51 ns/op 0 B/op 0 allocs/op
BenchmarkDeepEqual-8 2175002 559 ns/op 144 B/op 8 allocs/op
</code></pre><p>在该结构体的比较例子中，DeepEqual 比手动编写的代码来要慢100倍。</p>
<p>请注意，DeepEqual 会比较结构体中未导出的（小写的）字段。
另外，两个不同的类型永远不会被认为是深度相等的，即使它们是具有相同字段和值的不同结构体。</p>
<h2 id="不可比较性">不可比较性</h2>
<p>有些存在是不能被比较的，甚至被认为是与自己不相等的，例如具有 NaN 值的浮点变量或 func 类型。
例如，如果你在一个结构体中拥有这样的字段，那么如果使用 DeepEqual 进行比较，该结构体将不等于其自身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestF</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">NaN</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">TestF</span>, <span style="color:#a6e22e">TestF</span>)) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="bytesequal">bytes.Equal</h2>
<p>bytes.Equal 是专门为字节切片设计的一种比较方法。它比简单地用 for 循环比较两个切片要快得多。</p>
<p>值得注意的是，bytes.Equal 函数认为空切片和 nil 切片是相等的，而 reflect.DeepEqual 则相反。</p>

    

    
        
    
        <h1 id="第-16-章-内存管理">第 16 章 内存管理</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="结构体应该按值传递还是按引用传递">结构体应该按值传递还是按引用传递？</h2>
<p>在 Go 中，函数的参数总是按值传递。当一个结构体（或数组）类型的变量被传递到函数中时，整个结构体会被复制。
如果结构体的指针被传递，那么这个指针会被复制，但它所指向的结构体不会被复制。拷贝的是 8 个字节内存（对于 64 位架构），而不是该结构体的大小。
那么，这是否意味着将结构体作为指针传递会更好？经典回答——这要看情况。</p>
<p>分配一个结构体（或数组）的指针：</p>
<ol>
<li>将其放在堆中，而不是像通常情况下放到栈中；</li>
<li>垃圾收集器来管理堆内存的分配。</li>
</ol>
<p>如果你想复习一下栈与堆的关系，可以看看这个 
    <span class="link-wrapper">
        <a
            
            href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"
            target="_blank"
        >
            stackoverflow 帖子
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
。就本章而言，了解这些就足够了：堆栈——快，堆——慢。</p>
<p>这意味着如果分配结构体比传递它们更频繁，那么在栈中复制它们会更快：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">h</span>, <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">byValue</span>() <span style="color:#a6e22e">myStruct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">myStruct</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">c</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">d</span>: <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">e</span>: <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#a6e22e">f</span>: <span style="color:#e6db74">&#34;baz&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">g</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">h</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">i</span>: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">byReference</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">myStruct</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">c</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">d</span>: <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">e</span>: <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#a6e22e">f</span>: <span style="color:#e6db74">&#34;baz&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">g</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">h</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">i</span>: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkByValue</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">myStruct</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 拷贝整个结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 但要通过栈内存来实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">byValue</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkByReference</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在堆上为结构体分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 并只返回它的一个指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">byReference</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>BenchmarkByValue-8 476965734 2.499 ns/op 0 B/op 0 allocs/op 
BenchmarkByReference-8 24860521 45.86 ns/op 96 B/op 1 allocs/op
</code></pre><p>在这个初级案例中，按值传递（不涉及堆或垃圾收集器）的速度是按引用传递的 18 倍。</p>
<p>为了说明这个观点，让我们做一个相反的初级案例，分配一次结构体，只把它传递给函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">myStruct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">c</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>: <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">e</span>: <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#a6e22e">f</span>: <span style="color:#e6db74">&#34;baz&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">h</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">i</span>: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">byValue</span>() <span style="color:#a6e22e">myStruct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">byReference</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>BenchmarkByValue-8 471494428 2.509 ns/op 0 B/op 0 allocs/op
BenchmarkByReference-8 1000000000 0.2484 ns/op 0 B/op 0 allocs/op
</code></pre><p>当变量只被传来传去，但不被分配时——通过引用会快很多。</p>
<p>想要了解更多细节，请查看这篇 Vincent Blanchon 的 
    <span class="link-wrapper">
        <a
            
            href="https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963"
            target="_blank"
        >
            经典文章
        </a>
        <img src="/assets/img/icons/external-link-icon.svg" height="12" width="12" />
    </span>
。</p>
<p>虽然这一章是关于哪个更快，但在许多应用中，代码的清晰度和一致性将比性能更重要，当然，这又是一个单独的讨论。
总之，不要认为复制变量会很慢，如果性能很重要的话，请使用优秀的 Go 分析工具。</p>
<h2 id="给-c-语言开发者的说明">给 C 语言开发者的说明</h2>
<p>在 Go 中，对内存管理的要求更为严格。指针运算是不允许的，也不可能有悬空的指针。
但像这样的事情是完全可以的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">byReference</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">myStruct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">myStruct</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">c</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">d</span>: <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">e</span>: <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#a6e22e">f</span>: <span style="color:#e6db74">&#34;baz&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">g</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">h</span>: <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">i</span>: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Go 的编译器很智能，会将该结构体移至堆中。</p>

    

    
        
    
        <h1 id="第-17-章-日志">第 17 章 日志</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="logfatal-和-logpanic">log.Fatal 和 log.Panic</h2>
<p>在 Go 中，使用日志包进行日志记录时，log.Fatal 和log.Panic 这两个函数有一个陷阱在等着你。
与你期望的日志函数不同，这些函数不仅仅是用不同的日志级别记录一条消息，它们还终止了整个应用程序。
log.Fatal 干净地退出应用程序，log.Panic 调用运行时警告。下面是 Go 日志包中的实际函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#75715e">// Fatal 相当于在 Print() 之后调用 os.Exit(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">v</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">Output</span>(<span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprint</span>(<span style="color:#a6e22e">v</span><span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Panic 相当于在 Print() 之后调用 panic()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Panic</span>(<span style="color:#a6e22e">v</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprint</span>(<span style="color:#a6e22e">v</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">Output</span>(<span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>    panic(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    

    
        
    
        <h1 id="第-18-章-时间">第 18 章 时间</h1>
<blockquote>
<p>当前译本仍不稳定，如翻译有问题请及时联系 
        <a
            
            href="mailto:jacob953@csu.edu.cn"
        >
            jacob953@csu.edu.cn
        </a>
。</p>
</blockquote>
<h2 id="使用-timeloadlocation-从文件中读取数据">使用 time.LoadLocation 从文件中读取数据</h2>
<p>在 Go 中，这是我个人而言最喜欢的一个坑。在时区之间转换，首先要需要加载位置信息。事实证明，每次调用 time.LoadLocation 都会从一个文件中读取数据。在格式化大量 CSV 报告的每一行时，这不是最好的做法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Golang" data-lang="Golang"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkLocation</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">n</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">loc</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">LoadLocation</span>(<span style="color:#e6db74">&#34;Asia/Kolkata&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">In</span>(<span style="color:#a6e22e">loc</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkLocation2</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">loc</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">LoadLocation</span>(<span style="color:#e6db74">&#34;Asia/Kolkata&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">n</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">In</span>(<span style="color:#a6e22e">loc</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>BenchmarkLocation-8 16810 76179 ns/op 58192 B/op 14 allocs/op
BenchmarkLocation2-8 188887110 6.97 ns/op 0 B/op 0 allocs/op
</code></pre>
    

    

        </main>

<script src="/darker-corners-of-go/assets/js/uwe-uwe.js" type="text/javascript"></script>
<script type="text/javascript">
    UWE_UWE.FOOTNOTES.init();
    UWE_UWE.TABS.init();
</script></body>
</html>
